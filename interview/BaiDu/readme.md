# 自我介绍
姓名 + 学校 + 做过什么 + 有过什么成绩 + 为什么能胜任
掘金写过文章，做过什么项目，沟通能力强，管理过兴趣社团，对前端感兴趣，前端反馈强。。。
看中百度在未来AI发展的潜力

# 1. 数组上的方法，在js中的意义？
var a = []
a.push()
a.pop()

1. 创建对象字面量在v8的执行过程中相当于 new了一个构造函数，通常我们不去直接new构造函数，因为不够简洁直观
2. 因为a相当于new Array()得到的，那么该对象的隐式原型(_proto_) === Array.prototype(显示原型),v8在查找属性的时候会先在对象上查找，
如果找不到则会顺着对象的原型往上查找

new会创建一个对象，让对象的隐式原型等于显示原型，让this指向这个对象，返回这个对象

# 2. promise有几种状态？可以重复改变吗？
    1. 三种 Pending，Fulfilled，Rejected 一经变更无法修改

    - 手撕红绿灯算法

# 3. 输出结果

# 4. 聊聊你对语意化的理解
- 有哪些：header,nav,aside,artical,section,footer

- 优点：可读性好，搜索引擎优化（SEO），更好地支持各种终端，便于无障碍阅读

# 5. 斐波那契数列

# 6. 用过什么AI工具
    1. ChatGPT，文心一言，通义千问(刻意练习prompt技巧，生成简单的前端网页，知识点的学习总结)
    2. copilot 提升开发效率
    3. 最近在学习，transformer ，OpenAI 技能，对大模型很感兴趣，也在学习langchain，LLM，huggingface
    4. 自己准备一个大模型，介绍你对他的理解

# 7. 讲一讲TCP请求的三次握手和四次挥手
    - 三次握手 是TCP协议建立连接时产生的
        1. 客户端发送连接请求到服务器端，客户端状态变更进入 SYN-SENT 状态
        2. 服务端接收到请求连接报文后，返回一个应答（ACK序号），服务端进入 SYN-RECEIVED 状态
        3. 客户端接收到了同意连接的应答后，向服务端发送一个确认收到的报文。再进入 ESTABLISHED 状态，连接建立成功
    
    - 为什么一定要三次握手？两次行不行？
        不行，假设客户端给服务端发送了一个建立连接请求A，但是因为网络环境差，这个请求A超时了，那么TCP会启动超时重传机制，再发送一个新的建立连接请求B，
        服务器端接受到B请求后应答，如果此时就完成了建立连接的话，当客户端和服务端通信完成后，便释放了连接，双方都进入closed状态。假设此时A请求又抵达了服务端，
        那么服务端会认为客户端又要建立新的连接，从而应答该请求并进入ESTABLISHED状态，而此时的客户端是closed状态，那么服务端就会一直等待，造成资源浪费。

    - 四次挥手
        1. 客户端A认为数据发送完成，向服务端B发送释放连接请求
        2. B收到释放连接请求后，返回一个ACK报文，并进入到CLOSE_WAIT 状态，此时不再接受A发送的数据，但是B任然可以给A发送数据
        3. B如果此时还有没发完的数据，就会继续发送，发完后向A发送释放连接的请求，B进入到LAST_ACK 状态
        4. A收到B的释放连接请求，向B发送应答，进入CLOSED 状态，B收到该应答后，释放连接，进入CLOSED 状态

# 8. 说一说跨域
    https://www.baidu.com/
    https://192.168.1.100:8080/user
    https://192.168.1.100:8080/list
    协议号  域名（IP地址） 端口号 路径

    - 同源策略：协议号-域名-端口号   都相同的地址，浏览器才认为是同源

    - 跨域：后端返回给浏览器的数据会被浏览器的同源策略拦截

    - 同源策略的目的是数据安全

## 解决跨域（开发阶段好调试）
    https://192.168.1.100:8080（前端Vue）
        
    https://192.168.1.100:8080（后端go）

1. JSONP --- 借助script标签上的src属性不受同源策略的影响这一机制，来实现跨域
        (1) ajax请求受同源策略的影响，但是<script>标签上的src属性不受同源策略的影响，而且该属性也能使浏览器发送一个GET请求，所以可以利用这个特点来绕过同源策略
            1. 借助script的src属性给后端发送一个请求，且携带一个参数('callback')
            2. 前端在window对象上添加了一个 callback 函数
            3. 后端接收到这个参数 'callback' 后，将要返回给前端的数据data和 这个参数'callback' 进行拼接，成'callback(data)',并返回
            4. 因为window上已经有一个callback函数，后端又返回了一个形如'callback(data)',浏览器会将该字符串执行成callback的调用
        (2) 缺点：1. 需要后端支持，2. 只能支持GET请求
    
2. CORS(Cross-Origin Resource Sharing) 跨域资源共享 --- 后端通过设置响应头来告诉浏览器不要拒绝后端的响应

3. node代理 （vite 只在开发环境下生效）

4. nginx代理 （类似CORS，配置白名单）（生产环境下常用）

5. domain （在iframe中，当父级页面和子级页面的 子域 不同时，通过设置document.domain = 'xxx' 来将xxx定位基础域，从而实现跨域）

6. postMessage (在iframe中，通过postMessage来实现跨域)