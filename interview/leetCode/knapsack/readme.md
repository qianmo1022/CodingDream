## 0-1背包问题

背包 bagWeight 容量上限 4kg
最大价值 dp
物品数组 value [15,20,30]
    weight [1,3,4]

- 01背包 每件物品只有一件
    - 1 拿 
        重量加大了，价值大了
    - 0 不拿
        不影响前面的最优解
    完全背包 物品的数量 不限
    多重背包 每个物品的数量都不详

- 暴力破解法，能不能做？时间复杂度？ O(2^n) 不合适的

- 动态规划去解决
    - 定义dp数组 dp[i][j] 二维？ 留点印象
        最优子结构 dp[i][j] 最后一个是最值 dp[value.length][j]
        清楚 i j 的含义是什么？ i 表示第 i 个物品，j 表示背包的重量
        物品i放进容量为j的背包中，得到的最大价值

        矩阵法 dp矩阵
    - 状态转移方程
        dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])
    - 初始化 重要工作
        子结构的分析 状态的方向
    - 迭代
    - 返回结果

## 滚动数组     背包优化
    将二维优化为一维 ？ 老虎机  状态可以压缩
    上一行的状态计算完成后，可以迭代到下一行，拷贝上一行，再来计算    
    麻将牌
    - 定义dp[j] 容量为j的背包最大价值是多少？
    - 状态转移方程
        dp[j] = max(dp[j],dp[j-weight[i]]+value[i])
    - 初始化
        dp[0] = 0
        0
    - 迭代
        for(i = 0;i < weight.length;i++){
            for(j = bagWeight;j >= weight[i];j--){
                dp[j] = max(dp[j],dp[j-weight[i]]+value[i])
            }
        }
        极限想法
        如果内循环为for(j = 0;j < bagWeight;j++){}，那么
        dp[1] = dp[1-1] + 15 = 15
        dp[2] = dp[2-1] + 15 = 30

        递减
        dp[2] = dp[2-1] + 15 = 15
        dp[1] = dp[1-1] + 15 = 15