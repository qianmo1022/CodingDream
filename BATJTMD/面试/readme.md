# 原型和原型链

1.  显式原型 prototype
2.  隐式原型 __proto__

- 原型的作用：
    让所有的实例对象都有一个公有的属性和方法

- 原型链：
    因为对象都有自己的__proto__属性，V8在查找属性和方法的时候，会先在对象的显示属性中查找，如果找不到，就会去对象的__proto__中查找，如果还是找不到，就会顺着__proto__属性中查找，直到找到目标或者null为止。这种查找的关系链条就叫做原型链。

- new 的实现
  1.  创建一个新对象
  2.  将新对象的 __proto__ 指向构造函数的 prototype
  3.  将构造函数内部的 this 指向新对象
  4.  执行构造函数内部的代码
  5.  当构造函数中有返回值且返回值的类型为引用类型时，new会返回构造函数的return值，否则才返回新对象(如果构造返回的是null，那么还是返回新对象，只有typeof会把null当作Object类型)

- 所有的对象都有隐式原型吗？
    Object.create(null) 创建出来的是一个没有隐式原型的空对象

# var let const 的区别
1.  var 没有块级作用域，let const + {} 有块级作用域 （for循环中使用var声明i，for循环外可以访问到i，使用let声明i则不会）
2.  var 会声明提升，let const 不会
3.  var 可以重复声明，let const 不可以
4.  const 声明的变量不能被重新赋值，也不能声明一个不赋值的变量
5.  var 声明的全局变量会挂载到window上，let const 不会

- 暂时性死区：
    使用 let 或 const 声明的变量，形成了块级作用域时，在变量声明前访问该变量会报错，即使块级作用域外也声明了相同的变量，也无法访问，这就是暂时性死区

# 继承
    - 让子类能访问到父类的属性和方法
    1.  原型链继承: 子类无法给父类传参
    2.  构造函数继承: 子类可以给父类传参，但是子类无法访问到父类的属性和方法（即无法继承父类的原型），父类的属性和方法只能通过子类的实例访问
    3.  组合继承: 父类的属性和方法可以被子类访问，但是父类的构造函数执行了两次

    4.  原型式继承:  Object.create() 创建一个空对象，然后让空对象的__proto__指向父类的prototype，然后再返回这个空对象
    5.  寄生组合继承

    6.  class继承: ES6的class继承，通过extends + super关键字实现继承（super使得子类能够向父类传参）

# proxy
    - ES6 新增的语法，用于代理对象，代理对象上的读取、设置、函数调用等13种行为，Vue3主要依靠proxy实现响应式
# reflect
    - 相当于Object的2.0版本，将新的方法封装到Reflect中，方便使用，比如Reflect.get()、Reflect.set()、Reflect.deleteProperty()等方法

# map, filter, reduce，forEach, for...of
- map: 遍历数组，将数组中的每一项都执行一次回调函数，并返回一个新数组
- filter: 遍历数组，将数组中满足条件的那些项保留到新数组，并返回一个新数组
- reduce: 接收两个参数，第一个是回调函数，第二个是回调中的第一个参数，遍历数组，将每次返回的值作为下一次回调的第一个参数

- forEach: 无法使用传统的控制语句(break, return)来终止循环
- for...of: 可以使用传统的控制语句(break, return)来终止循环,但是拿不到下标

# Map
- Map 是 ES6 新增的数据结构，用于存储键值对，键值对中的键是唯一的，并且可以任意类型，并且可以遍历；而Object 只能存储键值对，键是字符串，并且键是唯一的

# 异步
 - js 默认是单线程的语言
 
 - 进程：进程是操作系统进行资源分配和调度的基本单位，是一个独立的执行环境。每个进程都有自己独立的内存空间、系统资源（如文件描述符）等。
 - 线程：线程是进程中的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存地址空间、文件描述符等），但拥有自己的栈空间。
## 解决方案
1. 回调函数：回调地狱，代码可读性差，维护困难
2. Promise：解决回调地狱的问题
    - then 方法的返回值是一个新的 promise 状态为 pending， then 的 pending 状态会根据上一个 promise 的修改而修改