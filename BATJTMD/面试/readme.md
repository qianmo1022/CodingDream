# 原型和原型链

1.  显式原型 prototype
2.  隐式原型 __proto__

- 原型的作用：
    让所有的实例对象都有一个公有的属性和方法

- 原型链：
    因为对象都有自己的__proto__属性，V8在查找属性和方法的时候，会先在对象的显示属性中查找，如果找不到，就会去对象的__proto__中查找，如果还是找不到，就会顺着__proto__属性中查找，直到找到目标或者null为止。这种查找的关系链条就叫做原型链。

- new 的实现
  1.  创建一个新对象
  2.  将新对象的 __proto__ 指向构造函数的 prototype
  3.  将构造函数内部的 this 指向新对象
  4.  执行构造函数内部的代码
  5.  当构造函数中有返回值且返回值的类型为引用类型时，new会返回构造函数的return值，否则才返回新对象(如果构造返回的是null，那么还是返回新对象，只有typeof会把null当作Object类型)

- 所有的对象都有隐式原型吗？
    Object.create(null) 创建出来的是一个没有隐式原型的空对象

# var let const 的区别
1.  var 没有块级作用域，let const + {} 有块级作用域 （for循环中使用var声明i，for循环外可以访问到i，使用let声明i则不会）
2.  var 会声明提升，let const 不会
3.  var 可以重复声明，let const 不可以
4.  const 声明的变量不能被重新赋值，也不能声明一个不赋值的变量
5.  var 声明的全局变量会挂载到window上，let const 不会

- 暂时性死区：
    使用 let 或 const 声明的变量，形成了块级作用域时，在变量声明前访问该变量会报错，即使块级作用域外也声明了相同的变量，也无法访问，这就是暂时性死区

# 继承
    - 让子类能访问到父类的属性和方法
    1.  原型链继承: 子类无法给父类传参
    2.  构造函数继承: 子类可以给父类传参，但是子类无法访问到父类的属性和方法（即无法继承父类的原型），父类的属性和方法只能通过子类的实例访问
    3.  组合继承: 父类的属性和方法可以被子类访问，但是父类的构造函数执行了两次

    4.  原型式继承:  Object.create() 创建一个空对象，然后让空对象的__proto__指向父类的prototype，然后再返回这个空对象
    5.  寄生组合继承

    6.  class继承: ES6的class继承，通过extends + super关键字实现继承（super使得子类能够向父类传参）


